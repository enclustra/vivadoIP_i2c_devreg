------------------------------------------------------------
-- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	use ieee.math_real.all;

library work;
	use work.i2c_devreg_pkg.all;
	use work.psi_common_array_pkg.all;
	use work.psi_common_math_pkg.all;
	use work.psi_common_logic_pkg.all;
	use work.psi_common_i2c_master_pkg.all;
	use work.psi_tb_i2c_pkg.all;
	use work.psi_tb_txt_util.all;
	use work.psi_tb_activity_pkg.all;
	use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity i2c_multi_devreg_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of i2c_multi_devreg_tb is
	-- *** Fixed Generics ***
	constant ClockFrequency_g : real := 125.0e6;
	constant I2cFrequency_g : real := 1.0e6;
	constant UpdatePeriod_g : real := 500.0e-6;
	constant NumOfReg_g : integer := 2;
	constant InternalTriState_g : boolean := true;
	
	-- *** Not Assigned Generics (default values) ***
	constant BusBusyTimeout_g : real := 1.0e-3;
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_Stimuli_c : integer := 0;
	constant TbProcNr_i2c_c : integer := 1;
	
	-- *** DUT Signals ***
	-- Shared Signals
	signal Clk : std_logic := '1';
	signal Rst : std_logic := '1';
	
	signal UpdateTrig : std_logic := '0';
	signal UpdateEna : std_logic := '0';
	signal I2cScl : std_logic := '0';
	signal I2cSda : std_logic := '0';
	
	-- Instance A
	signal ToRomVldA : std_logic := '0';
	signal ToRomAddrA : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal FromRomEntryA : CfgRomEntry_t;
	signal FromRomVldA : std_logic := '0';
	signal UpdateDoneA : std_logic := '0';
	signal RegAddrA : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal RegDoutA : std_logic_vector(31 downto 0) := (others => '0');
	
	-- Instance B
	signal ToRomVldB : std_logic := '0';
	signal ToRomAddrB : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal FromRomEntryB : CfgRomEntry_t;
	signal FromRomVldB : std_logic := '0';
	signal UpdateDoneB : std_logic := '0';
	signal RegAddrB : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal RegDoutB : std_logic_vector(31 downto 0) := (others => '0');
	
	-- *** ROMs ***
	-- Instance A
	constant CfgRomA_c : CfgRom_t(0 to 1) := (
		0 => (	HasMux => '1', MuxAddr => X"05", MuxValue => X"AB", DevAddr => X"3D", CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0'),
		1 => (	HasMux => '0', MuxAddr => X"00", MuxValue => X"00", DevAddr => X"12", CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0')
	);
	
	-- Instance B
	constant CfgRomB_c : CfgRom_t(0 to 1) := (
		0 => (	HasMux => '1', MuxAddr => X"05", MuxValue => X"03", DevAddr => X"3D", CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0'),
		1 => (	HasMux => '0', MuxAddr => X"00", MuxValue => X"00", DevAddr => X"49", CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0')
	);
	
	-- *** Helper Functions ***
	procedure TestMemContent(	Addr			: in integer;
								Value			: in integer;
								signal Clk		: in std_logic;
								signal RegAddrS	: out std_logic_vector;
								signal RegDoutS	: in std_logic_vector;
								Msg				: in string := "No Msg") is
	begin
		wait until rising_edge(Clk);
		RegAddrS <= std_logic_vector(to_unsigned(Addr, RegAddrS'length));
		wait until rising_edge(Clk);
		RegAddrS <= std_logic_vector(to_unsigned(0, RegAddrS'length));
		wait until rising_edge(Clk);
		StdlvCompareInt (Value, RegDoutS, "Wrong Register Value - " & Msg, true);
	end procedure;
	
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dutA : entity work.i2c_devreg
		generic map (
			ClockFrequency_g => ClockFrequency_g,
			I2cFrequency_g => I2cFrequency_g,
			UpdatePeriod_g => UpdatePeriod_g,
			InternalTriState_g => InternalTriState_g,
			NumOfReg_g => NumOfReg_g
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			ToRomVld => ToRomVldA,
			ToRomAddr => ToRomAddrA,
			FromRomVld => FromRomVldA,
			FromRomEntry => FromRomEntryA,
			UpdateTrig => UpdateTrig,
			UpdateEna => UpdateEna,
			UpdateDone => UpdateDoneA,
			RegAddr => RegAddrA,
			RegI2cWrite => '0',
			RegI2cRead => '0',
			RegDout => RegDoutA,
			RegDin => (others => '0'),
			I2cScl => I2cScl,
			I2cSda => I2cSda
		);
		
	i_dutB : entity work.i2c_devreg
		generic map (
			ClockFrequency_g => ClockFrequency_g,
			I2cFrequency_g => I2cFrequency_g,
			UpdatePeriod_g => UpdatePeriod_g,
			InternalTriState_g => InternalTriState_g,
			NumOfReg_g => NumOfReg_g
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			ToRomVld => ToRomVldB,
			ToRomAddr => ToRomAddrB,
			FromRomVld => FromRomVldB,
			FromRomEntry => FromRomEntryB,
			UpdateTrig => UpdateTrig,
			UpdateEna => UpdateEna,
			UpdateDone => UpdateDoneB,
			RegAddr => RegAddrB,
			RegI2cWrite => '0',
			RegI2cRead => '0',
			RegDout => RegDoutB,
			RegDin => (others => '0'),
			I2cScl => I2cScl,
			I2cSda => I2cSda
		);
		
	------------------------------------------------------------
	-- ROM Emulation
	------------------------------------------------------------	
	p_romA : process(Clk)
	begin
		if rising_edge(Clk) then
			FromRomVldA <= ToRomVldA;
			if ToRomVldA = '1' then				
				FromRomEntryA <= CfgRomA_c(to_integer(unsigned(ToRomAddrA)) mod 2);
			end if;
		end if;
	end process;
	
	p_romB : process(Clk)
	begin
		if rising_edge(Clk) then
			FromRomVldB <= ToRomVldB;
			if ToRomVldB = '1' then				
				FromRomEntryB <= CfgRomB_c(to_integer(unsigned(ToRomAddrB)) mod 2);
			end if;
		end if;
	end process;
		
	------------------------------------------------------------
	-- I2C Emulation
	------------------------------------------------------------		
	I2cPullup(I2cScl, I2cSda);
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until Rst = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(125e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			Clk <= not Clk;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(Clk);
		wait until rising_edge(Clk);
		Rst <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** Stimuli ***
	p_Stimuli : process
		variable StartTime_v : time;
	begin
		I2cSetFrequency(I2cFrequency_g);
		I2cBusFree(I2cScl, I2cSda);
		
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		wait until rising_edge(Clk);
		
		-- *** Test Update***
		UpdateEna <= '1';
		wait for 1 us;
		wait until rising_edge(Clk);
		UpdateTrig <= '1';
		wait until rising_edge(Clk);
		UpdateTrig <= '0';
		
		
		ClockedWaitFor('1', UpdateDoneA, Clk);
		ClockedWaitFor('1', UpdateDoneB, Clk);
		
		TestMemContent(0, 16#81#, Clk, RegAddrA, RegDoutA);
		TestMemContent(1, 16#82#, Clk, RegAddrA, RegDoutA);
		
		TestMemContent(0, 16#91#, Clk, RegAddrB, RegDoutB);
		TestMemContent(1, 16#92#, Clk, RegAddrB, RegDoutB);

		wait for 100 us;
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_Stimuli_c) <= '1';
		wait;
	end process;
	
	-- *** i2c slave ***
	p_i2c_slave : process
	begin
		I2cBusFree(I2cScl, I2cSda);
		wait for 1 us;
	
		-- First, Instance B wins arbitration because of its mux value
		I2cSlaveWaitStart(I2cScl, I2cSda, "Start B0");
		I2cSlaveExpectByte(I2cGetAddr(16#05#, I2c_WRITE), I2cScl, I2cSda, "MuxAddr B0", I2c_ACK);
		I2cSlaveExpectByte(16#03#, I2cScl, I2cSda, "MuxValue B0", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "MuxStop B0");
		I2cSlaveWaitStart(I2cScl, I2cSda, "MuxStart B0");
		I2cSlaveExpectByte(I2cGetAddr(16#3D#, I2c_READ), I2cScl, I2cSda, "DevAddr B0", I2c_ACK);
		I2cSlaveSendByte(16#91#, I2cScl, I2cSda, "Data B0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "Stop B0");
		
		-- Then, Instance A wins arbitration because MUX-Addr wins agains Device Addr of Instance B (second access)
		I2cSlaveWaitStart(I2cScl, I2cSda, "Start A0");
		I2cSlaveExpectByte(I2cGetAddr(16#05#, I2c_WRITE), I2cScl, I2cSda, "MuxAddr A0", I2c_ACK);
		I2cSlaveExpectByte(16#AB#, I2cScl, I2cSda, "MuxValue A0", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "MuxStop A0");
		I2cSlaveWaitStart(I2cScl, I2cSda, "MuxStart A0");
		I2cSlaveExpectByte(I2cGetAddr(16#3D#, I2c_READ), I2cScl, I2cSda, "DevAddr A0", I2c_ACK);
		I2cSlaveSendByte(16#81#, I2cScl, I2cSda, "Data A0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "Stop A0");	

		-- Then, Instance A wins arbitration because of Device Addr 
		I2cSlaveWaitStart(I2cScl, I2cSda, "Start A1");
		I2cSlaveExpectByte(I2cGetAddr(16#12#, I2c_READ), I2cScl, I2cSda, "DevAddr A1", I2c_ACK);
		I2cSlaveSendByte(16#82#, I2cScl, I2cSda, "Data A1", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "Stop A1");	

		-- Then, Instance B gets the bus without arbitration (last access pending)
		I2cSlaveWaitStart(I2cScl, I2cSda, "Start B1");
		I2cSlaveExpectByte(I2cGetAddr(16#49#, I2c_READ), I2cScl, I2cSda, "DevAddr B1", I2c_ACK);
		I2cSlaveSendByte(16#92#, I2cScl, I2cSda, "Data B1", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "Stop B1");			
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_i2c_c) <= '1';
		wait;
	end process;
	

	
	
end;
