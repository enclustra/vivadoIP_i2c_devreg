------------------------------------------------------------
-- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	use ieee.math_real.all;

library work;
	use work.i2c_devreg_pkg.all;
	use work.psi_common_array_pkg.all;
	use work.psi_common_math_pkg.all;
	use work.psi_common_logic_pkg.all;
	use work.psi_common_i2c_master_pkg.all;
	use work.psi_tb_i2c_pkg.all;
	use work.psi_tb_txt_util.all;
	use work.psi_tb_activity_pkg.all;
	use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity i2c_devreg_tb is
	generic (
		InternalTriState_g : boolean := true
	);
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of i2c_devreg_tb is
	-- *** Fixed Generics ***
	constant ClockFrequency_g : real := 125.0e6;
	constant I2cFrequency_g : real := 1.0e6;
	constant UpdatePeriod_g : real := 500.0e-6;
	constant NumOfReg_g : integer := 3;
	
	-- *** Not Assigned Generics (default values) ***
	constant BusBusyTimeout_g : real := 1.0e-3 ;
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_Stimuli_c : integer := 0;
	constant TbProcNr_i2c_c : integer := 1;
	signal StimCase : integer := -1;
	signal I2cCase : integer := -1;
	
	-- *** DUT Signals ***
	signal Clk : std_logic := '1';
	signal Rst : std_logic := '1';
	signal ToRomVld : std_logic := '0';
	signal ToRomAddr : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal FromRomEntry1 : CfgRomEntry_t;
	signal FromRomEntry : CfgRomEntry_t;
	signal FromRomVld : std_logic := '0';
	signal FromRomVld1 : std_logic := '0';
	signal UpdateTrig : std_logic := '0';
	signal UpdateEna : std_logic := '0';
	signal UpdateDone : std_logic := '0';
	signal AccessFailed : std_logic := '0';
	signal RegAddr : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal RegI2cWrite : std_logic := '0';
	signal RegI2cRead : std_logic := '0';
	signal RegDout : std_logic_vector(31 downto 0) := (others => '0');
	signal RegDin : std_logic_vector(31 downto 0) := (others => '0');
	signal RegFifoFull : std_logic := '0';
	signal RegFifoEmpty	: std_logic := '0';
	signal I2cScl : std_logic := '0';
	signal I2cSda : std_logic := '0';
	signal I2cScl_I : std_logic := '0';
	signal I2cScl_O : std_logic := '0';
	signal I2cScl_T : std_logic := '0';
	signal I2cSda_I : std_logic := '0';
	signal I2cSda_O : std_logic := '0';
	signal I2cSda_T : std_logic := '0';
	signal BusBusy : std_logic := '0';
	
	-- *** Helper Functions ***
	procedure WaitForCase(	signal TestCase : in integer;
							Value 			: in integer) is
	begin
		if TestCase /= Value then
			wait until TestCase = Value;
		end if;
	end procedure;
	
	procedure TestMemContent(	Addr			: in integer;
								Value			: in integer;
								signal Clk		: in std_logic;
								signal RegAddrS	: out std_logic_vector;
								signal RegDoutS	: in std_logic_vector;
								Msg				: in string := "No Msg") is
	begin
		wait until rising_edge(Clk);
		RegAddrS <= std_logic_vector(to_unsigned(Addr, RegAddr'length));
		wait until rising_edge(Clk);
		RegAddrS <= std_logic_vector(to_unsigned(0, RegAddr'length));
		wait until rising_edge(Clk);
		StdlvCompareInt (Value, RegDoutS, "Wrong Register Value - " & Msg, true);
	end procedure;
	
	function AddrSlv(	addr : integer) return std_logic_vector is
	begin
		return std_logic_vector(to_unsigned(addr, 8));
	end function;
	
	-- *** USER CONSTANTS ***
	constant SLAVE_ADDR 	: integer := 16#12#;
	constant DATA_OFFS  	: integer := 16#34#;
	constant CMD_OFFS		: integer := 16#0A#;
	constant CMD_BYTES		: t_aslv32(0 to 4)	:= (X"00000000", X"0000000A", X"00000A0B", X"000A0B0C", X"0A0B0C0D");
	constant MUX_ADDR 		: integer := 16#5C#;
	constant MUX_VAL    	: integer := 16#89#;
	constant MUX_VAL_SLV 	: std_logic_vector(7 downto 0)	:= std_logic_vector(to_unsigned(MUX_VAL, 8));
	constant DATA32			: integer := 16#34353637#;
	
	-- ROM Contents
	constant ROM_NOMUX_NOCMD_1DATA : CfgRomEntry_t :=  (	
		HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
		CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');

	constant ROM_1MUX_NOCMD_1DATA : CfgRomEntry_t := (
		HasMux => '1',  MuxAddr => AddrSlv(MUX_ADDR), MuxValue => MUX_VAL_SLV, DevAddr => AddrSlv(SLAVE_ADDR),  
		CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');
		
	constant ROM_NOMUX_1CMD_1DATA : CfgRomEntry_t := (
		HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
		CmdBytes => 1, CmdData => CMD_BYTES(1), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');
		
	constant ROM_NOMUX_2CMD_NODATA : CfgRomEntry_t := (
		HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
		CmdBytes => 2, CmdData => CMD_BYTES(2), DatBytes => 0, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');

	constant ROM_1MUX_2CMD_1DATA : CfgRomEntry_t := (
		HasMux => '1',  MuxAddr => AddrSlv(MUX_ADDR), MuxValue => MUX_VAL_SLV, DevAddr => AddrSlv(SLAVE_ADDR),  
		CmdBytes => 2, CmdData => CMD_BYTES(2), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');
		
	constant ROM_NOMUX_NOCMD_4DATA : CfgRomEntry_t := (
		HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
		CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 4, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');
		
	constant ROM_UNUSED : CfgRomEntry_t := (
		HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => (others => 'X'),
		CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 0, AutoRead => '0', AutoWrite => '0', DataLSByteFirst => '0');
	
	shared variable CfgRom : CfgRom_t(0 to 2**log2ceil(NumOfReg_g)-1) := (others => ROM_UNUSED);
	
	-- *** Slave Procedures ***
	procedure Slave_NOMUX_NOCMD_1DATA(	signal I2cScl 	: inout std_logic;
										signal I2cSda 	: inout std_logic;
										Msg				: in	string := "No Msg";
										DataOffs		: in	integer := 0) is
	begin
		I2cSlaveWaitStart(I2cScl, I2cSda, Msg & " START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, Msg & " DATA-ADDR", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS+DataOffs, I2cScl, I2cSda, Msg & " DATA-BYTE0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, Msg & " STOP");
	end procedure;
	
	procedure Slave_1MUX_NOCMD_1DATA(	signal I2cScl 	: inout std_logic;
										signal I2cSda 	: inout std_logic;
										Msg				: in	string := "No Msg";
										DataOffs		: in	integer := 0) is
	begin
		I2cSlaveWaitStart(I2cScl, I2cSda, Msg & " START");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, Msg & " MUX-ADDR", I2c_ACK);
		I2cSlaveExpectByte(MUX_VAL, I2cScl, I2cSda, Msg & " MUX-DATA", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, Msg & " MUX-STOP");
		I2cSlaveWaitStart(I2cScl, I2cSda, Msg & " MUX-START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, Msg & " DATA-ADDR", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS+DataOffs, I2cScl, I2cSda, Msg & " DATA-BYTE0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, Msg & " STOP");
	end procedure;
	
	procedure Slave_NOMUX_1CMD_1DATA(	signal I2cScl 	: inout std_logic;
										signal I2cSda 	: inout std_logic;
										Msg				: in	string := "No Msg";
										DataOffs		: in	integer := 0) is
	begin
		I2cSlaveWaitStart(I2cScl, I2cSda, Msg & " START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, Msg & " CMD-ADDR", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS, I2cScl, I2cSda, Msg & " CMD-DATA", I2c_ACK);
		I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, Msg & " CMD-REPSTART");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, Msg & " DATA-ADDR", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS+DataOffs, I2cScl, I2cSda, Msg & " DATA-BYTE0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, Msg & " STOP");
	end procedure;
	
	procedure Slave_1MUX_2CMD_1DATA(	signal I2cScl 	: inout std_logic;
										signal I2cSda 	: inout std_logic;
										Msg				: in	string := "No Msg";
										DataOffs		: in	integer := 0) is
	begin
		I2cSlaveWaitStart(I2cScl, I2cSda, Msg & " START");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, Msg & " MUX-ADDR", I2c_ACK);
		I2cSlaveExpectByte(MUX_VAL, I2cScl, I2cSda, Msg & " MUX-DATA", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, Msg & " MUX-STOP");
		I2cSlaveWaitStart(I2cScl, I2cSda, Msg & " MUX-START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, Msg & " CMD-ADDR", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+0, I2cScl, I2cSda, Msg & " CMD-DATA", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+1, I2cScl, I2cSda, Msg & " CMD-DATA", I2c_ACK);
		I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, Msg & " CMD-REPSTART");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, Msg & " DATA-ADDR", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS+DataOffs, I2cScl, I2cSda, Msg & " DATA-BYTE0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, Msg & " STOP");
	end procedure;
	
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dut : entity work.i2c_devreg
		generic map (
			ClockFrequency_g => ClockFrequency_g,
			I2cFrequency_g => I2cFrequency_g,
			UpdatePeriod_g => UpdatePeriod_g,
			InternalTriState_g => InternalTriState_g,
			NumOfReg_g => NumOfReg_g
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			ToRomVld => ToRomVld,
			ToRomAddr => ToRomAddr,
			FromRomVld => FromRomVld,
			FromRomEntry => FromRomEntry,
			UpdateTrig => UpdateTrig,
			UpdateEna => UpdateEna,
			UpdateDone => UpdateDone,
			BusBusy => BusBusy,
			AccessFailed => AccessFailed,
			RegAddr => RegAddr,
			RegI2cWrite => RegI2cWrite,
			RegI2cRead => RegI2cRead,
			RegDout => RegDout,
			RegDin => RegDin,
			RegFifoFull => RegFifoFull,
			RegFifoEmpty => RegFifoEmpty,
			I2cScl => I2cScl,
			I2cSda => I2cSda,
			I2cScl_I => I2cScl_I,
			I2cScl_O => I2cScl_O,
			I2cScl_T => I2cScl_T,
			I2cSda_I => I2cSda_I,
			I2cSda_O => I2cSda_O,
			I2cSda_T => I2cSda_T
		);
		
	------------------------------------------------------------
	-- I2C Emulation
	------------------------------------------------------------		
	I2cPullup(I2cScl, I2cSda);
	g_triState : if not InternalTriState_g generate
		I2cScl <= 'Z' when I2cScl_T = '1' else I2cScl_O;
		I2cScl_I <= To01X(I2cScl);
		I2cSda <= 'Z' when I2cSda_T = '1' else I2cSda_O;
		I2cSda_I <= To01X(I2cSda);
	end generate;
	
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until Rst = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(125e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			Clk <= not Clk;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(Clk);
		wait until rising_edge(Clk);
		Rst <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** Stimuli ***
	p_Stimuli : process
		variable StartTime_v : time;
	begin
		I2cSetFrequency(I2cFrequency_g);
		I2cBusFree(I2cScl, I2cSda);
		
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		wait until rising_edge(Clk);
		
		-- *** Test Update Disabled ***
		print(">> Test Update Disabled");
		StimCase <= 0;	
		wait until rising_edge(Clk);	

		-- Disabled
		UpdateEna <= '0';
		wait until rising_edge(Clk);
		PulseSig(UpdateTrig, Clk);
		StartTime_v := now;
		while now < StartTime_v + 20 us loop
			wait until rising_edge(Clk);
			assert I2cScl = 'H' report "###ERROR###: Unexpeted Scl Activity" severity error;
			assert I2cSda = 'H' report "###ERROR###: Unexpeted Sda Activity" severity error;
		end loop;	
		
		-- No ROM Entries
		UpdateEna <= '1';
		wait until rising_edge(Clk);
		PulseSig(UpdateTrig, Clk);
		StartTime_v := now;
		while now < StartTime_v + 20 us loop
			wait until rising_edge(Clk);
			assert I2cScl = 'H' report "###ERROR###: Unexpeted Scl Activity" severity error;
			assert I2cSda = 'H' report "###ERROR###: Unexpeted Sda Activity" severity error;
		end loop;
		
		WaitForCase(I2cCase, 0);
		wait for 10 us;
		
		-- *** Test Single Auto Read ***
		print(">> Test Single Auto Read ");
		StimCase <= 1;	
		wait until rising_edge(Clk);

		-- 1 Byte, no Mux, no cmd
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS, Clk, RegAddr, RegDout, "A");
		
		-- 1 Byte, no Mux, with command bytes
		for i in 1 to 4 loop
			wait for 5 us;
			CfgRom(1) := (	HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
							CmdBytes => i, CmdData => CMD_BYTES(i), DatBytes => 1, AutoRead => '1', AutoWrite => '0', DataLSByteFirst => '0');
			PulseSig(UpdateTrig, Clk);
			wait for 1 us;
			ClockedWaitFor('1', UpdateDone, Clk);
			TestMemContent(1, DATA_OFFS+i, Clk, RegAddr, RegDout, "B " & to_string(i));
		end loop;
		
		-- 1 Byte Mux, Mux, no cmd
		wait for 5 us;
		CfgRom(1) := ROM_1MUX_NOCMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS, Clk, RegAddr, RegDout, "C");
		
		-- 1 Byte Mux, Mux, 2 byte cmd
		wait for 5 us;
		CfgRom(1) := ROM_1MUX_2CMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout, "D");
		
		-- 4 Byte, no Mux, no command bytes
		wait for 5 us;
		CfgRom(1) := ROM_NOMUX_NOCMD_4DATA;
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA32, Clk, RegAddr, RegDout, "E");
		
		-- Other master took over bus after Mux related stop/start
		wait for 5 us;
		CfgRom(1) := ROM_1MUX_NOCMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS, Clk, RegAddr, RegDout, "C");
			
		WaitForCase(I2cCase, 1);		
		wait for 10 us;		
		
		-- *** Test Single Auto Write ***
		print(">> Test Single Auto Write");
		CfgRom := (others => ROM_UNUSED);
		StimCase <= 2;	
		wait until rising_edge(Clk);

		-- 0 Byte, no Mux, 2 cmd
		CfgRom(1) := ROM_NOMUX_2CMD_NODATA;
		CfgRom(1).AutoRead := '0';
		CfgRom(1).AutoWrite := '1';
		WaitClockCycles(5, Clk);
		PulseSig(UpdateTrig, Clk);
		WaitClockCycles(10, Clk);
		ClockedWaitFor('0', BusBusy, Clk);

		-- 1 Byte, no Mux, no cmd
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		CfgRom(1).AutoRead := '0';
		CfgRom(1).AutoWrite := '1';
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		RegDin  <= std_logic_vector(to_unsigned(DATA_OFFS+3, 32));
		PulseSig(RegI2cWrite, Clk);
		RegAddr <= (others => 'X');
		RegDin <= (others => 'X');
		WaitClockCycles(5, Clk);
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;		
		ClockedWaitFor('0', BusBusy, Clk);
		TestMemContent(1, DATA_OFFS+3, Clk, RegAddr, RegDout);
		
		WaitForCase(I2cCase, 2);		
		wait for 10 us;

		
		-- *** Test Multi Auto Read ***
		print(">> Test Multi Auto Read ");
		StimCase <= 3;	
		wait until rising_edge(Clk);
	
		-- Configure
		CfgRom(0) := ROM_NOMUX_NOCMD_1DATA;
		CfgRom(1) := ROM_1MUX_2CMD_1DATA;
		CfgRom(2) := ROM_1MUX_NOCMD_1DATA;
		-- Execute
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		-- Check
		TestMemContent(0, DATA_OFFS, Clk, RegAddr, RegDout, "A");
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout, "B");
		TestMemContent(2, DATA_OFFS+2, Clk, RegAddr, RegDout, "C");
		-- Restore
		CfgRom := (others => ROM_UNUSED);
		
		WaitForCase(I2cCase, 3);		
		wait for 10 us;	
		
		
		-- *** Test NACK retry ***	
		-- Only some cases are tested because they all boil down to the same state in i2c_devreg anyway.
		print(">> Test NACK retry ");
		StimCase <= 4;	
		wait until rising_edge(Clk);
					
		-- Retry on Mux-Addr NACK
		CfgRom(1) := ROM_1MUX_NOCMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+2, Clk, RegAddr, RegDout);
		wait for 5 us;
		
		-- Retry on Cmd-Data NACK
		CfgRom(1) := ROM_NOMUX_1CMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout);
		wait for 5 us;
		
		-- Retry on Dat-Addr NACK (multi)
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		CfgRom(2) := ROM_NOMUX_1CMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+4, Clk, RegAddr, RegDout);
		TestMemContent(2, DATA_OFFS+5, Clk, RegAddr, RegDout);
		CfgRom := (others => ROM_UNUSED);
		
		-- Test NACK failed (single)
		CfgRom(1) := ROM_1MUX_NOCMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', AccessFailed, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, 16#FFFFFFFF#, Clk, RegAddr, RegDout);		
		wait for 5 us;
		
		-- Test NACK failed (multi)
		CfgRom(1) := ROM_1MUX_NOCMD_1DATA;
		CfgRom(2) := ROM_NOMUX_1CMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', AccessFailed, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, 16#FFFFFFFF#, Clk, RegAddr, RegDout, "1");
		TestMemContent(2, DATA_OFFS+0, Clk, RegAddr, RegDout, "2");
		CfgRom := (others => ROM_UNUSED);
					
		WaitForCase(I2cCase, 4);		
		wait for 10 us;	
		
		-- *** Test Arbitration Behavior ***
		print(">> Test Arbitration Behavior ");
		StimCase <= 5;	
		wait until rising_edge(Clk);		
		
		-- Retry after lost arbitration
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+0, Clk, RegAddr, RegDout, "1");
		
		-- Test Start while bus busy
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		-- .. Wait for bus being busy
		I2cSlaveWaitStart(I2cScl, I2cSda, "B-Busy Start");
		wait for 3 us;
		-- .. start update while busy
		PulseSig(UpdateTrig, Clk);
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout, "1");
		
		WaitForCase(I2cCase, 5);		
		wait for 10 us;	
		
		-- *** Test User Triggered Reads ***
		print(">> Test User Triggered Reads ");
		CfgRom := (others => ROM_UNUSED);
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		CfgRom(2) := ROM_1MUX_NOCMD_1DATA;
		StimCase <= 6;	
		wait until rising_edge(Clk);
		
		-- Single Read
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		PulseSig(RegI2cRead, Clk);
		RegAddr <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS+3, Clk, RegAddr, RegDout, "Single Read");	
		wait for 5 us;

		-- Queued Reads
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(2, RegAddr'length));
		PulseSig(RegI2cRead, Clk);
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		PulseSig(RegI2cRead, Clk);
		RegAddr <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS+0, Clk, RegAddr, RegDout, "Read 1");	
		TestMemContent(2, DATA_OFFS+1, Clk, RegAddr, RegDout, "Read 2");
		wait for 5 us;
		
		-- During update		
		CfgRom(0) := ROM_NOMUX_1CMD_1DATA;
		CfgRom(0).AutoRead	:= '0'; -- only for user operation
		PulseSig(UpdateTrig, Clk);
		I2cSlaveWaitStart(I2cScl, I2cSda, "Update - Start");
		RegAddr <= std_logic_vector(to_unsigned(0, RegAddr'length));
		PulseSig(RegI2cRead, Clk);	
		RegAddr <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(0, DATA_OFFS+5, Clk, RegAddr, RegDout, "Read 0");
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+4, Clk, RegAddr, RegDout, "Read 1");
		TestMemContent(2, DATA_OFFS+3, Clk, RegAddr, RegDout, "Read 2");
		wait for 5 us;	
		
		-- Arbit Lost
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		PulseSig(RegI2cRead, Clk);
		RegAddr <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS, Clk, RegAddr, RegDout, "Arbit Lost");	
		wait for 5 us;
		
		-- NACK retry
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		PulseSig(RegI2cRead, Clk);
		RegAddr <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout, "NACK retry");	
		wait for 5 us;
		
		-- NACK retry failing
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		PulseSig(RegI2cRead, Clk);
		RegAddr <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', AccessFailed, Clk);
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, 16#FFFFFFFF#, Clk, RegAddr, RegDout, "NACK retry failing");	
		wait for 5 us;			

		WaitForCase(I2cCase, 6);		
		wait for 10 us;	

		-- *** Test User Triggered Writes ***
		print(">> Test User Triggered Writes ");
		CfgRom := (others => ROM_UNUSED);
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		CfgRom(2) := ROM_1MUX_NOCMD_1DATA;
		StimCase <= 7;	
		wait until rising_edge(Clk);
		
		-- Single Write
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		RegDin  <= std_logic_vector(to_unsigned(DATA_OFFS+1, 32));
		PulseSig(RegI2cWrite, Clk);
		RegAddr <= (others => 'X');
		RegDin <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout, "Single Write");	
		wait for 5 us;	
		
		-- During update		
		CfgRom(0) := ROM_NOMUX_1CMD_1DATA;
		CfgRom(0).AutoRead	:= '0'; -- only for user operation
		PulseSig(UpdateTrig, Clk);
		I2cSlaveWaitStart(I2cScl, I2cSda, "Update - Start");
		RegAddr <= std_logic_vector(to_unsigned(0, RegAddr'length));
		RegDin  <= std_logic_vector(to_unsigned(DATA_OFFS+2, 32));
		PulseSig(RegI2cWrite, Clk);	
		RegAddr <= (others => 'X');
		RegDin <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(0, DATA_OFFS+2, Clk, RegAddr, RegDout, "Read 0");
		ClockedWaitFor('1', UpdateDone, Clk);
		TestMemContent(1, DATA_OFFS+0, Clk, RegAddr, RegDout, "Read 1");
		TestMemContent(2, DATA_OFFS+1, Clk, RegAddr, RegDout, "Read 2");
		CfgRom(0) := ROM_UNUSED;
		wait for 5 us;	
		
		-- NACK Addr retry
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		RegDin  <= std_logic_vector(to_unsigned(DATA_OFFS+7, 32));
		PulseSig(RegI2cWrite, Clk);
		RegAddr <= (others => 'X');
		RegDin <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS+7, Clk, RegAddr, RegDout, "NACK retry");	
		wait for 5 us;
		
		-- NACK Addr retry failing
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		RegDin  <= std_logic_vector(to_unsigned(DATA_OFFS+1, 32));
		PulseSig(RegI2cWrite, Clk);
		RegAddr <= (others => 'X');
		RegDin <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', AccessFailed, Clk);
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, 16#FFFFFFFF#, Clk, RegAddr, RegDout, "NACK fail");	
		wait for 5 us;
		
		-- NACK Data
		StdlCompare(1, RegFifoEmpty, "FIFO not empty");
		RegAddr <= std_logic_vector(to_unsigned(1, RegAddr'length));
		RegDin  <= std_logic_vector(to_unsigned(DATA_OFFS+3, 32));
		PulseSig(RegI2cWrite, Clk);
		RegAddr <= (others => 'X');
		RegDin <= (others => 'X');
		WaitClockCycles(5, Clk);
		StdlCompare(0, RegFifoEmpty, "FIFO empty");
		ClockedWaitFor('1', RegFifoEmpty, Clk);
		TestMemContent(1, DATA_OFFS+3, Clk, RegAddr, RegDout, "NACK data");	
		wait for 5 us;

		WaitForCase(I2cCase, 7);		
		wait for 10 us;		

		-- *** Test Update Timer ***
		print(">> Test Update Timer ");
		CfgRom := (others => ROM_UNUSED);
		CfgRom(1) := ROM_NOMUX_NOCMD_1DATA;
		StimCase <= 8;	
		wait until rising_edge(Clk);
		
		WaitForValueStdl(UpdateDone, '1', UpdatePeriod_g*(1 sec), "Update did not happen");
		TestMemContent(1, DATA_OFFS+5, Clk, RegAddr, RegDout, "Wrong data");	
		
		WaitForCase(I2cCase, 8);		
		wait for 10 us;	

		-- *** Test LSB First Byte Order ***
		print(">> Test LSB First Byte Order ");
		CfgRom := (others => ROM_UNUSED);		
		StimCase <= 9;	
		wait until rising_edge(Clk);
		
		-- 4 Byte, no Mux, no command bytes 
		wait for 5 us;
		CfgRom(1) := ROM_NOMUX_NOCMD_4DATA;
		CfgRom(1).DataLSByteFirst := '1';
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('1', UpdateDone, Clk);
		-- Bytes are sent in reverse order by slave, so they should be available in normal order here
		TestMemContent(1, DATA32, Clk, RegAddr, RegDout, "A");	
		
		-- Test Auto Write
		CfgRom(1).AutoRead := '0';
		CfgRom(1).AutoWrite := '1';
		WaitClockCycles(5, Clk);
		PulseSig(UpdateTrig, Clk);
		WaitClockCycles(10, Clk);
		ClockedWaitFor('0', BusBusy, Clk);

		WaitForCase(I2cCase, 9);		
		wait for 10 us;			

		wait for 100 us;
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_Stimuli_c) <= '1';
		wait;
	end process;
	
	-- *** i2c slave ***
	p_i2c_slave : process
	begin
		I2cBusFree(I2cScl, I2cSda);
	
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		wait until rising_edge(Clk);
		
		-- *** Test Update Disabled***
		WaitForCase(StimCase, 0);		
		I2cCase <= 0;
		
		-- *** Test Single Auto Read ***
		WaitForCase(StimCase, 1);
		
		-- 1 Byte, no Mux, no cmd
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "A");
		
		-- 1 Byte, no Mux, with command bytes
		for i in 1 to 4 loop
			I2cSlaveWaitStart(I2cScl, I2cSda, "Start " & to_string(i));
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "CmdAddr " & to_string(i), I2c_ACK);
			for b in 0 to i-1 loop
				I2cSlaveExpectByte(CMD_OFFS+b, I2cScl, I2cSda, "CmdData " & to_string(i) & " Byte " & to_string(b), I2c_ACK);
			end loop;
			I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, "Rep. Start " & to_string(i));	
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "DatAddr " & to_string(i), I2c_ACK);			
			I2cSlaveSendByte(DATA_OFFS+i, I2cScl, I2cSda, "DatRead " & to_string(i), I2c_NACK);
			I2cSlaveWaitStop(I2cScl, I2cSda, "Stop " & to_string(i));
		end loop;
		
		-- 1 Byte Mux, Mux, no cmd
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "C");

		-- 1 Byte Mux, Mux, 2 byte cmd
		Slave_1MUX_2CMD_1DATA(I2cScl, I2cSda, "D", DataOffs => 1);
		
		-- 4 Byte, no Mux, no command bytes
		I2cSlaveWaitStart(I2cScl, I2cSda, "E Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "E DataAddr", I2c_ACK);
		for i in 0 to 2 loop
			I2cSlaveSendByte(DATA_OFFS+i, I2cScl, I2cSda, "E DataData " & to_string(i), I2c_ACK);
		end loop;
		I2cSlaveSendByte(DATA_OFFS+3, I2cScl, I2cSda, "E DataData 3", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "E Stop");
		
		-- Other master took over bus after Mux related stop/start
		-- lossing bus during stop/start
		I2cSlaveWaitStart(I2cScl, I2cSda, "F START");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "F MUX-ADDR", I2c_ACK);
		I2cSlaveExpectByte(MUX_VAL, I2cScl, I2cSda, "F MUX-DATA", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "F MUX-STOP");
		I2cSlaveWaitStart(I2cScl, I2cSda, "F MUX-START");
		I2cMasterSendByte(16#00#, I2cScl, I2cSda, "F-Arbit DatAddr", I2c_NACK);
		I2cMasterSendStop(I2cScl, I2cSda, "F-Arbit Stop");
		-- retry successfully
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "F");
		
		I2cCase <= 1;
		
		-- *** Test Single Auto Write ***
		WaitForCase(StimCase, 2);
		
		-- 0 Byte, no Mux, 2 cmd
		I2cSlaveWaitStart(I2cScl, I2cSda, "A START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "A CMD-ADDR", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+0, I2cScl, I2cSda, "A CMD-BYTE0", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+1, I2cScl, I2cSda, "A CMD-BYTE1", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A STOP");
			
		-- 1 Byte, no Mux, no cmd
		-- the access happens twice (once for writing the RAM, once in the update cycle)
		for i in 0 to 1 loop
			I2cSlaveWaitStart(I2cScl, I2cSda, "B START");
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "B DATA-ADDR", I2c_ACK);
			I2cSlaveExpectByte(DATA_OFFS+3, I2cScl, I2cSda, "B DATA-BYTE0", I2c_ACK);
			I2cSlaveWaitStop(I2cScl, I2cSda, "B STOP");
		end loop;
		
		-- TODO: cmd only
		
		I2cCase <= 2;
		
		-- *** Test Multi Auto Read ***
		WaitForCase(StimCase, 3);
		
		-- 1 Byte, no Mux, no cmd
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "A");
		
		-- 1 Byte Mux, Mux, 2 byte cmd
		Slave_1MUX_2CMD_1DATA(I2cScl, I2cSda, "B", DataOffs => 1);
		
		-- 1 Byte Mux, Mux, no cmd
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "C", DataOffs => 2);
		
		I2cCase <= 3;
		
		-- *** Test NACK retry ***	
		WaitForCase(StimCase, 4);
		
		-- Retry on Mux-Addr NACK
		-- .. Stop after failing transfer
		I2cSlaveWaitStart(I2cScl, I2cSda, "A-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "A-Fail MuxAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A-Fail Stop");	
		-- .. and retry
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "C", DataOffs => 2);
		
		
		-- Retry on Cmd-Data NACK
		-- .. Stop after failing transfer
		I2cSlaveWaitStart(I2cScl, I2cSda, "B-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "B-Fail CmdAddr", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+0, I2cScl, I2cSda, "B-Fail CmdData", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "B-Fail Stop");	
		-- .. and retry
		Slave_NOMUX_1CMD_1DATA(I2cScl, I2cSda, "B", DataOffs => 1);
		
		-- Retry on Dat-Addr NACK (multi)
		-- .. Stop after failing transfer
		I2cSlaveWaitStart(I2cScl, I2cSda, "C-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "C-Fail CmdAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "C-Fail Stop");
		-- .. and retry
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "C", DataOffs => 4);
		-- .. and check if next transfer is fine 
		Slave_NOMUX_1CMD_1DATA(I2cScl, I2cSda, "B", DataOffs => 5);
		
		-- Test NACK failed (single)
		-- .. Stop after failing transfer
		I2cSlaveWaitStart(I2cScl, I2cSda, "A-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "A-Fail MuxAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A-Fail Stop");	
		-- .. Fail again
		I2cSlaveWaitStart(I2cScl, I2cSda, "A-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "A-Fail MuxAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A-Fail Stop");	

		-- Test NACK failed (multi)	
		-- .. Stop after failing transfer
		I2cSlaveWaitStart(I2cScl, I2cSda, "A-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "A-Fail MuxAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A-Fail Stop");	
		-- .. Fail again
		I2cSlaveWaitStart(I2cScl, I2cSda, "A-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "A-Fail MuxAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A-Fail Stop");	
		-- .. and check if next transfer is fine 
		Slave_NOMUX_1CMD_1DATA(I2cScl, I2cSda, "B", DataOffs => 0);		
		
		I2cCase <= 4;
		
		-- *** Test Arbitration Behavior ***
		WaitForCase(StimCase, 5);	
		
		-- Retry after lost arbitration
		-- .. Loose arbitration
		I2cSlaveWaitStart(I2cScl, I2cSda, "A-Arbit Start");
		I2cMasterSendByte(16#00#, I2cScl, I2cSda, "A-Arbit DatAddr", I2c_NACK);
		I2cMasterSendStop(I2cScl, I2cSda, "A-Arbit Stop");
		-- .. And check retry
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "A", DataOffs => 0);
		
		-- Test Start while bus busy
		-- .. Bus is busy during start
		I2cMasterSendStart(I2cScl, I2cSda, "B-Busy Start");
		I2cMasterSendByte(16#00#, I2cScl, I2cSda, "B-Busy DatAddr", I2c_NACK);
		I2cMasterSendStop(I2cScl, I2cSda, "B-Busy Stop");
		-- .. check access after bus is free
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "B -Transfer", DataOffs => 1);
		
		I2cCase <= 5;
		
		-- *** Test User Triggered Reads ***
		WaitForCase(StimCase, 6);
		
		-- Single Read
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "A", DataOffs => 3);
		
		-- Queued Reads
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "B1", DataOffs => 1);
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "B2", DataOffs => 0);
		
		-- During update	
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "C1", DataOffs => 4); -- First of auto-update
		Slave_NOMUX_1CMD_1DATA(I2cScl, I2cSda, "C2", DataOffs => 5); -- User triggered	
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "C3", DataOffs => 3); -- Second of auto-update
		
		-- Arbit Lost
		-- .. Loose arbitration
		I2cSlaveWaitStart(I2cScl, I2cSda, "D-Arbit Start");
		I2cMasterSendByte(16#00#, I2cScl, I2cSda, "D-Arbit DatAddr", I2c_NACK);
		I2cMasterSendStop(I2cScl, I2cSda, "D-Arbit Stop");
		-- .. And check retry
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "D", DataOffs => 0);
		
		-- NACK retry
		-- ... failing access (NACK)
		I2cSlaveWaitStart(I2cScl, I2cSda, "E-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "E-Fail CmdAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "E-Fail Stop");
		-- .. And check retry
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "E", DataOffs => 1);
		
		-- NACK retry failing
		for i in 0 to 1 loop
			-- ... failing access (NACK)
			I2cSlaveWaitStart(I2cScl, I2cSda, "F-Fail Start " & to_string(i));
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "F-Fail CmdAddr " & to_string(i), I2c_NACK);
			I2cSlaveWaitStop(I2cScl, I2cSda, "F-Fail Stop " & to_string(i));
		end loop;
		
		I2cCase <= 6;
		
		-- *** Test User Triggered Writes ***
		WaitForCase(StimCase, 7);
		
		-- Single Write
		I2cSlaveWaitStart(I2cScl, I2cSda, "A START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "A DATA-ADDR", I2c_ACK);
		I2cSlaveExpectByte(DATA_OFFS+1, I2cScl, I2cSda, "A DATA-BYTE0", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A STOP");
		
		-- During update	
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "B1", DataOffs => 0); -- First of auto-update
		-- ... write
		I2cSlaveWaitStart(I2cScl, I2cSda, "B2 CMD-START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "B2 CMD-ADDR", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS, I2cScl, I2cSda, "B2 CMD-DATA", I2c_ACK);
		I2cSlaveExpectByte(DATA_OFFS+2, I2cScl, I2cSda, "B2 DATA-BYTE0", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "B2 STOP");		
		-- ... continue update
		Slave_1MUX_NOCMD_1DATA(I2cScl, I2cSda, "B3", DataOffs => 1); -- Second of auto-update
		
		-- NACK Addr retry
		-- ... failing access (NACK)
		I2cSlaveWaitStart(I2cScl, I2cSda, "C-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "C-Fail CmdAddr", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "C-Fail Stop");
		-- .. And check retry
		I2cSlaveWaitStart(I2cScl, I2cSda, "C START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "C DATA-ADDR", I2c_ACK);
		I2cSlaveExpectByte(DATA_OFFS+7, I2cScl, I2cSda, "C DATA-BYTE0", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "C STOP");
		
		-- NACK Addr retry failing
		for i in 0 to 1 loop
			-- ... failing access (NACK)
			I2cSlaveWaitStart(I2cScl, I2cSda, "D-Fail Start " & to_string(i));
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_Write), I2cScl, I2cSda, "D-Fail CmdAddr " & to_string(i), I2c_NACK);
			I2cSlaveWaitStop(I2cScl, I2cSda, "D-Fail Stop " & to_string(i));
		end loop;
		
		-- NACK Data
		-- ... failing access (NACK)
		I2cSlaveWaitStart(I2cScl, I2cSda, "E-Fail Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "E-Fail DATA-ADDR", I2c_ACK);
		I2cSlaveExpectByte(DATA_OFFS+3, I2cScl, I2cSda, "E-Fail DATA-BYTE0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "E-Fail Stop");
		-- .. And check retry
		I2cSlaveWaitStart(I2cScl, I2cSda, "E START");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "E DATA-ADDR", I2c_ACK);
		I2cSlaveExpectByte(DATA_OFFS+3, I2cScl, I2cSda, "E DATA-BYTE0", I2c_ACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "E STOP");				
		
		I2cCase <= 7;
		
		-- *** Test Update Timer ***
		WaitForCase(StimCase, 8);
		
		-- 1 Byte, no Mux, no cmd
		Slave_NOMUX_NOCMD_1DATA(I2cScl, I2cSda, "A", DataOffs => 5);

		I2cCase <= 8;
		
		-- *** Test LSB First Byte Order ***
		WaitForCase(StimCase, 9);
	
		-- 4 Byte, no Mux, no command bytes
		I2cSlaveWaitStart(I2cScl, I2cSda, "A Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "A DataAddr", I2c_ACK);
		-- send in reverse byte order
		for i in 3 downto 1 loop
			I2cSlaveSendByte(DATA_OFFS+i, I2cScl, I2cSda, "A DataData " & to_string(i), I2c_ACK);
		end loop;
		I2cSlaveSendByte(DATA_OFFS+0, I2cScl, I2cSda, "A DataData 0", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A Stop");	
		
		-- Test Auto Write
		I2cSlaveWaitStart(I2cScl, I2cSda, "B Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "B DataAddr", I2c_ACK);
		-- send in reverse byte order
		for i in 3 downto 0 loop
			I2cSlaveExpectByte(DATA_OFFS+i, I2cScl, I2cSda, "B DataData " & to_string(i), I2c_ACK);
		end loop;
		I2cSlaveWaitStop(I2cScl, I2cSda, "B Stop");	
		
		I2cCase <= 9;
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_i2c_c) <= '1';
		wait;
	end process;
	
	-- *** Emulate Rom ***
	p_rom : process(Clk)
	begin
		if rising_edge(Clk) then
			FromRomVld1 <= ToRomVld;
			FromRomVld <= FromRomVld1;
			if ToRomVld = '1' then				
				FromRomEntry1 <= CfgRom(to_integer(unsigned(ToRomAddr)));
			end if;
			FromRomEntry <= FromRomEntry1;
		end if;
	end process;
	
	
end;
