------------------------------------------------------------
-- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
-- All rights reserved.
------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	use ieee.math_real.all;

library work;
	use work.i2c_devreg_pkg.all;
	use work.psi_common_math_pkg.all;
	use work.psi_common_logic_pkg.all;
	use work.psi_common_i2c_master_pkg.all;
	use work.psi_tb_i2c_pkg.all;
	use work.psi_tb_txt_util.all;
	use work.psi_tb_activity_pkg.all;
	use work.psi_tb_compare_pkg.all;

------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity i2c_devreg_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of i2c_devreg_tb is
	-- *** Fixed Generics ***
	constant ClockFrequency_g : real := 125.0e6;
	constant I2cFrequency_g : real := 1.0e6;
	constant UpdatePeriod_g : real := 1.0e-3;
	constant InternalTriState_g : boolean := true;
	constant NumOfReg_g : integer := 3;
	
	-- *** Not Assigned Generics (default values) ***
	constant BusBusyTimeout_g : real := 1.0e-3 ;
	
	-- *** TB Control ***
	signal TbRunning : boolean := True;
	signal NextCase : integer := -1;
	signal ProcessDone : std_logic_vector(0 to 1) := (others => '0');
	constant AllProcessesDone_c : std_logic_vector(0 to 1) := (others => '1');
	constant TbProcNr_Stimuli_c : integer := 0;
	constant TbProcNr_i2c_c : integer := 1;
	signal StimCase : integer := -1;
	signal I2cCase : integer := -1;
	
	-- *** DUT Signals ***
	signal Clk : std_logic := '1';
	signal Rst : std_logic := '1';
	signal ToRom : ToRom_t;
	signal FromRom1 : FromRom_t;
	signal FromRom : FromRom_t;
	signal UpdateTrig : std_logic := '0';
	signal UpdateEna : std_logic := '0';
	signal RegAddr : std_logic_vector(log2ceil(NumOfReg_g)-1 downto 0) := (others => '0');
	signal RegI2cWrite : std_logic := '0';
	signal RegI2cRead : std_logic := '0';
	signal RegDout : std_logic_vector(31 downto 0) := (others => '0');
	signal RegDin : std_logic_vector(31 downto 0) := (others => '0');
	signal I2cScl : std_logic := '0';
	signal I2cSda : std_logic := '0';
	signal I2cScl_I : std_logic := '0';
	signal I2cScl_O : std_logic := '0';
	signal I2cScl_T : std_logic := '0';
	signal I2cSda_I : std_logic := '0';
	signal I2cSda_O : std_logic := '0';
	signal I2cSda_T : std_logic := '0';
	signal BusBusy : std_logic := '0';
	
	shared variable CfgRom : CfgRom_t(0 to 2**log2ceil(NumOfReg_g)-1) := 
		(others => (Vld => 'X', HasMux => '0', 
					MuxAddr => (others => 'X'), MuxValue => (others => 'X'),
					DevAddr => (others => 'X'), CmdBytes => 0, CmdData => (others => 'X'),
					DatBytes => 0, AutoRead => '0'));
	
	type CfgRom_t is array (natural range <>) of FromRom_t;
	
	-- *** Helper Functions ***
	procedure WaitForCase(	signal TestCase : in integer;
							Value 			: in integer) is
	begin
		if TestCase /= Value then
			wait until TestCase = Value;
		end if;
	end procedure;
	
	procedure TestMemContent(	Addr			: in integer;
								Value			: in integer;
								signal Clk		: in std_logic;
								signal RegAddrS	: out std_logic_vector;
								signal RegDoutS	: in std_logic_vector) is
	begin
		wait until rising_edge(Clk);
		RegAddrS <= std_logic_vector(to_unsigned(Addr, RegAddr'length));
		wait until rising_edge(Clk);
		RegAddrS <= std_logic_vector(to_unsigned(0, RegAddr'length));
		wait until rising_edge(Clk);
		StdlvCompareInt (Value, RegDoutS, "Wrong Register Value", false);
	end procedure;
	
	function AddrSlv(	addr : integer) return std_logic_vector is
	begin
		return std_logic_vector(to_unsigned(addr, 7));
	end function;
	
	-- *** USER CONSTANTS ***
	constant SLAVE_ADDR 	: integer := 16#12#;
	constant DATA_OFFS  	: integer := 16#34#;
	constant CMD_OFFS		: integer := 16#0A#;
	constant MUX_ADDR 		: integer := 16#5C#;
	constant MUX_VAL    	: integer := 16#89#;
	constant MUX_VAL_SLV 	: std_logic_vector(7 downto 0)	:= std_logic_vector(to_unsigned(MUX_VAL, 8));
	constant CMD_BYTES		: std_logic_vector(31 downto 0) := X"0D0C0B0A";
	constant DATA32			: integer := 16#34353637#;
	
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dut : entity work.i2c_devreg
		generic map (
			ClockFrequency_g => ClockFrequency_g,
			I2cFrequency_g => I2cFrequency_g,
			UpdatePeriod_g => UpdatePeriod_g,
			InternalTriState_g => InternalTriState_g,
			NumOfReg_g => NumOfReg_g
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			ToRom => ToRom,
			FromRom => FromRom,
			UpdateTrig => UpdateTrig,
			UpdateEna => UpdateEna,
			BusBusy => BusBusy,
			RegAddr => RegAddr,
			RegI2cWrite => RegI2cWrite,
			RegI2cRead => RegI2cRead,
			RegDout => RegDout,
			RegDin => RegDin,
			I2cScl => I2cScl,
			I2cSda => I2cSda,
			I2cScl_I => I2cScl_I,
			I2cScl_O => I2cScl_O,
			I2cScl_T => I2cScl_T,
			I2cSda_I => I2cSda_I,
			I2cSda_O => I2cSda_O,
			I2cSda_T => I2cSda_T
		);
		
	------------------------------------------------------------
	-- I2C Emulation
	------------------------------------------------------------		
	I2cPullup(I2cScl, I2cSda);
	g_triState : if not InternalTriState_g generate
		I2cScl <= 'Z' when I2cScl_T = '1' else I2cScl_O;
		I2cScl_I <= To01X(I2cScl);
		I2cSda <= 'Z' when I2cSda_T = '1' else I2cSda_O;
		I2cSda_I <= To01X(I2cSda);
	end generate;
	
	------------------------------------------------------------
	-- Testbench Control !DO NOT EDIT!
	------------------------------------------------------------
	p_tb_control : process
	begin
		wait until Rst = '0';
		wait until ProcessDone = AllProcessesDone_c;
		TbRunning <= false;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Clocks !DO NOT EDIT!
	------------------------------------------------------------
	p_clock_Clk : process
		constant Frequency_c : real := real(125e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			Clk <= not Clk;
		end loop;
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Resets
	------------------------------------------------------------
	p_rst_Rst : process
	begin
		wait for 1 us;
		-- Wait for two clk edges to ensure reset is active for at least one edge
		wait until rising_edge(Clk);
		wait until rising_edge(Clk);
		Rst <= '0';
		wait;
	end process;
	
	
	------------------------------------------------------------
	-- Processes
	------------------------------------------------------------
	-- *** Stimuli ***
	p_Stimuli : process
		variable StartTime_v : time;
	begin
		I2cSetFrequency(I2cFrequency_g);
		I2cBusFree(I2cScl, I2cSda);
		
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		wait until rising_edge(Clk);
		
		-- *** Test Update Disabled***
		print(">> Test Update Disabled");
		StimCase <= 0;	
		wait until rising_edge(Clk);	

		-- Disabled
		UpdateEna <= '0';
		wait until rising_edge(Clk);
		PulseSig(UpdateTrig, Clk);
		StartTime_v := now;
		while now < StartTime_v + 20 us loop
			wait until rising_edge(Clk);
			assert I2cScl = 'H' report "###ERROR###: Unexpeted Scl Activity" severity error;
			assert I2cSda = 'H' report "###ERROR###: Unexpeted Sda Activity" severity error;
		end loop;	
		
		-- No ROM Entries
		UpdateEna <= '1';
		wait until rising_edge(Clk);
		PulseSig(UpdateTrig, Clk);
		StartTime_v := now;
		while now < StartTime_v + 20 us loop
			wait until rising_edge(Clk);
			assert I2cScl = 'H' report "###ERROR###: Unexpeted Scl Activity" severity error;
			assert I2cSda = 'H' report "###ERROR###: Unexpeted Sda Activity" severity error;
		end loop;
		
		WaitForCase(I2cCase, 0);
		wait for 10 us;
		
		-- *** Test Single Auto Read ***
		print(">> Test Single Auto Read ");
		StimCase <= 1;	
		wait until rising_edge(Clk);

		-- 1 Byte, no Mux, no cmd
		CfgRom(1) := (	Vld => 'X', HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
						CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1');
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('0', BusBusy, Clk);
		TestMemContent(1, DATA_OFFS, Clk, RegAddr, RegDout);
		
		-- 1 Byte, no Mux, with command bytes
		for i in 1 to 4 loop
			wait for 5 us;
			CfgRom(1) := (	Vld => 'X', HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
							CmdBytes => i, CmdData => CMD_BYTES, DatBytes => 1, AutoRead => '1');
			PulseSig(UpdateTrig, Clk);
			wait for 1 us;
			ClockedWaitFor('0', BusBusy, Clk);
			TestMemContent(1, DATA_OFFS+i, Clk, RegAddr, RegDout);
		end loop;
		
		-- 1 Byte Mux, Mux, no cmd
		wait for 5 us;
		CfgRom(1) := (	Vld => 'X', HasMux => '1',  MuxAddr => AddrSlv(MUX_ADDR), MuxValue => MUX_VAL_SLV, DevAddr => AddrSlv(SLAVE_ADDR),  
						CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 1, AutoRead => '1');
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('0', BusBusy, Clk);
		TestMemContent(1, DATA_OFFS, Clk, RegAddr, RegDout);
		
		-- 1 Byte Mux, Mux, 2 byte cmd
		wait for 5 us;
		CfgRom(1) := (	Vld => 'X', HasMux => '1',  MuxAddr => AddrSlv(MUX_ADDR), MuxValue => MUX_VAL_SLV, DevAddr => AddrSlv(SLAVE_ADDR),  
						CmdBytes => 2, CmdData => CMD_BYTES, DatBytes => 1, AutoRead => '1');
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('0', BusBusy, Clk);
		TestMemContent(1, DATA_OFFS+1, Clk, RegAddr, RegDout);
		
		-- 4 Byte, no Mux, no command bytes
		wait for 5 us;
		CfgRom(1) := (	Vld => 'X', HasMux => '0',  MuxAddr => (others => 'X'), MuxValue => (others => 'X'), DevAddr => AddrSlv(SLAVE_ADDR),  
						CmdBytes => 0, CmdData => (others => 'X'), DatBytes => 4, AutoRead => '1');
		PulseSig(UpdateTrig, Clk);
		wait for 1 us;
		ClockedWaitFor('0', BusBusy, Clk);
		TestMemContent(1, DATA32, Clk, RegAddr, RegDout);
			
		WaitForCase(I2cCase, 1);
		
		wait for 10 us;		
		
		-- TODO: Test Timer Operatiopn
		-- TODO: Test Multi Bytes
		-- TODO: Test user force read
		-- TODO: Test user force write
		-- TODO: Test NACK behavior (device not present, skip)
		-- TODO: Test Arbitration behavior (retry)

		wait for 100 us;
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_Stimuli_c) <= '1';
		wait;
	end process;
	
	-- *** i2c slave ***
	p_i2c_slave : process
	begin
		I2cBusFree(I2cScl, I2cSda);
	
		-- start of process !DO NOT EDIT
		wait until Rst = '0';
		wait until rising_edge(Clk);
		
		-- *** Test Update Disabled***
		WaitForCase(StimCase, 0);		
		I2cCase <= 0;
		
		-- *** Test Single Auto Read ***
		WaitForCase(StimCase, 1);
		
		-- 1 Byte, no Mux, no cmd
		I2cSlaveWaitStart(I2cScl, I2cSda, "1");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "2", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS, I2cScl, I2cSda, "3", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "4");
		
		-- 1 Byte, no Mux, with command bytes
		for i in 1 to 4 loop
			I2cSlaveWaitStart(I2cScl, I2cSda, "Start " & to_string(i));
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "CmdAddr " & to_string(i), I2c_ACK);
			for b in 0 to i-1 loop
				I2cSlaveExpectByte(CMD_OFFS+b, I2cScl, I2cSda, "CmdData " & to_string(i) & " Byte " & to_string(b), I2c_ACK);
			end loop;
			I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, "Rep. Start " & to_string(i));	
			I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "DatAddr " & to_string(i), I2c_ACK);			
			I2cSlaveSendByte(DATA_OFFS+i, I2cScl, I2cSda, "DatRead " & to_string(i), I2c_NACK);
			I2cSlaveWaitStop(I2cScl, I2cSda, "Stop " & to_string(i));
		end loop;
		
		-- 1 Byte Mux, Mux, no cmd
		I2cSlaveWaitStart(I2cScl, I2cSda, "A Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "A MuxAddr", I2c_ACK);
		I2cSlaveExpectByte(MUX_VAL, I2cScl, I2cSda, "A MuxData", I2c_ACK);
		I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, "A RepStart");	
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "A DataAddr", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS, I2cScl, I2cSda, "A DataData", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "A Stop");

		-- 1 Byte Mux, Mux, 2 byte cmd
		I2cSlaveWaitStart(I2cScl, I2cSda, "B Start");
		I2cSlaveExpectByte(I2cGetAddr(MUX_ADDR, I2c_WRITE), I2cScl, I2cSda, "B MuxAddr", I2c_ACK);
		I2cSlaveExpectByte(MUX_VAL, I2cScl, I2cSda, "B MuxData", I2c_ACK);
		I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, "B RepStart 1");	
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_WRITE), I2cScl, I2cSda, "B CmdAddr", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+0, I2cScl, I2cSda, "B CmdData 0", I2c_ACK);
		I2cSlaveExpectByte(CMD_OFFS+1, I2cScl, I2cSda, "B CmdData 1", I2c_ACK);
		I2cSlaveWaitRepeatedStart(I2cScl, I2cSda, "B RepStart 2");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "B DataAddr", I2c_ACK);
		I2cSlaveSendByte(DATA_OFFS+1, I2cScl, I2cSda, "B DataData", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "B Stop");
		I2cCase <= 1;
		
		-- 4 Byte, no Mux, no command bytes
		I2cSlaveWaitStart(I2cScl, I2cSda, "C Start");
		I2cSlaveExpectByte(I2cGetAddr(SLAVE_ADDR, I2c_READ), I2cScl, I2cSda, "C DataAddr", I2c_ACK);
		for i in 0 to 2 loop
			I2cSlaveSendByte(DATA_OFFS+i, I2cScl, I2cSda, "C DataData " & to_string(i), I2c_ACK);
		end loop;
		I2cSlaveSendByte(DATA_OFFS+3, I2cScl, I2cSda, "C DataData 3", I2c_NACK);
		I2cSlaveWaitStop(I2cScl, I2cSda, "C Stop");
		
		-- end of process !DO NOT EDIT!
		ProcessDone(TbProcNr_i2c_c) <= '1';
		wait;
	end process;
	
	-- *** Emulate Rom ***
	p_rom : process(Clk)
	begin
		if rising_edge(Clk) then
			FromRom1.Vld <= '0';
			if ToRom.Vld = '1' then
				FromRom1 <= CfgRom(to_integer(unsigned(ToRom.Addr)));
				FromRom1.Vld <= '1';
			end if;
			FromRom <= FromRom1;
		end if;
	end process;
	
	
end;
